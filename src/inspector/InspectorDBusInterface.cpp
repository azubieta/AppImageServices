// system
#include <sstream>

// libraries
#include <appimage/appimage++.h>
#include <appimage/utils/ResourcesExtractor.h>
#include <XdgUtils/DesktopEntry/DesktopEntry.h>

// local
#include "utils.h"
#include "InspectorDBusInterface.h"

// generated by `qt5_add_dbus_adaptor` cmake function
#include "inspectoradaptor.h"

InspectorDBusInterface::InspectorDBusInterface(QObject* parent) : QObject(parent) {
    new InspectorAdaptor(this);
    QDBusConnection dbus = QDBusConnection::sessionBus();
    bool operationSucceed;
    operationSucceed = dbus.registerObject(INSPECTOR_DBUS_OBJECT_PATH, this);
    if (!operationSucceed)
        qCritical() << "Unable to register d-bus object: " << INSPECTOR_DBUS_OBJECT_PATH;

    operationSucceed = dbus.registerService(INSPECTOR_DBUS_INTERFACE_NAME);
    if (!operationSucceed)
        qCritical() << "Unable to register d-bus service: " << INSPECTOR_DBUS_INTERFACE_NAME;
}

QStringList InspectorDBusInterface::listContents(const QString& appImagePath) {
    QStringList files;
    try {
        QString path = removeUriProtocolFromPath(appImagePath);
        appimage::core::AppImage appImage(path.toStdString());
        for (const auto& entry: appImage.files())
            files << QString::fromStdString(entry);

    } catch (const appimage::core::AppImageError& error) {
        qWarning() << "Unable to list AppImage contents: " << appImagePath;
    }

    return files;
}

QString InspectorDBusInterface::getApplicationInfo(QString appImagePath) {
    try {
        QString path = removeUriProtocolFromPath(appImagePath);
        if (QFile::exists(path)) {
            AppImageInfoReader reader(path);
            QVariantMap appInfo = reader.readAppInfo();

            QJsonDocument document(QJsonObject::fromVariantMap(appInfo));
            return document.toJson();
        } else {
            return "{\"error\":\"Invalid path\"}";
        }
    } catch (std::runtime_error error) {
        std::cerr << "Error: " << error.what() << std::endl;
        return "{\"error\":\"" + QString::fromStdString(error.what()) + "\"}";
    }
}

bool InspectorDBusInterface::extractFile(QString appImagePath, QString source, QString target) {
    try {
        QString path = removeUriProtocolFromPath(appImagePath);
        appimage::core::AppImage appImage(path.toStdString());
        appimage::utils::ResourcesExtractor extractor(appImage);

        std::map<std::string, std::string> extractArgs = {{source.toStdString(), target.toStdString()}};
        extractor.extractTo(extractArgs);
        return true;
    } catch (const std::runtime_error& error) {
        qWarning() << "Unable to extract AppImage file " << source << " to " << target << " error: " << error.what();
        return false;
    }
}

bool InspectorDBusInterface::extractApplicationIcon(const QString& appImagePath, const QString& targetPath) {
    std::string iconPath;
    try {
        QString path = removeUriProtocolFromPath(appImagePath);
        appimage::core::AppImage appImage(path.toStdString());
        appimage::utils::ResourcesExtractor extractor(appImage);

        std::string desktopEntryPath = extractor.getDesktopEntryPath();
        std::stringstream stream(extractor.extractText(desktopEntryPath));
        XdgUtils::DesktopEntry::DesktopEntry desktopEntry(stream);

        std::string iconName = static_cast<std::string>(desktopEntry["Desktop Entry/Icon"]);
        std::vector<std::string> iconPaths = extractor.getIconFilePaths(iconName);
        iconPath = iconPaths.empty() ? ".DirIcon" : iconPaths[0];

        extractor.extractTo({{iconPath, targetPath.toStdString()}});
        return true;
    } catch (const std::runtime_error& error) {
        qWarning() << "Unable to extract AppImage icon " << QString::fromStdString(iconPath) << " to " << targetPath
                   << " error: " << error.what();
        return false;
    }
}

InspectorDBusInterface::~InspectorDBusInterface() = default;
